# ***线程安全性***

## 定义 : 多线程访问某个类时，不管采用何种调度方式或线程如何交替执行，在主调代码中不需要额外的同步或协调。该类都能表现正常，称该类线程安全。线程安全性主要体现在三个方面，原子性，可见性，有序性。

+ ### 原子性 : 提供互斥访问，同一时刻只能有一个线程对他进行操作。

+ ### 可见性 : 一个线程对主内存的修改可以及时被其他线程观察到。

+ ### 有序性 : 一个线程观察其他线程中指令执行顺序，由于指令重排的存在，观察结果一般杂乱无序。

1. ## 原子性

   1. ### atomic包

      + #### AtomicXXX : CAS原理，Unsafe.compareAndSwapInt

        #### (循环比较，当工作内存与主内存一致时才执行写入)

      + #### AtomicLong，LongAdder 的区别

        #### (并发不高时都是直接写入，并发高时 LongAdder 对数进行更细粒度的拆分，提升了并发读写能力但是会丢失统计的精确度，如要用于精确计数的话会不准确)

      + #### AtomicReference，AtomicReferenceFieldUpdater

        #### (AtomicReference 提供无锁访问共享资源，CompareAndSet方法

        ####  AtomicReferenceFieldUpdater 提供无锁访问类中某字段，要求该字段非静态而     且被volatile修饰)

      + #### AtomicStampReference : 解决 CAS 的 ABA 问题

        #### (每次改动都会变更版本号)

   2. ### synchronized(依赖JVM，该关键字无法继承，子类需单独声明)

      #### sychronized : 不可中断，适合竞争不激烈，可读性好

      #### Lock : 可中断，多样化同步，竞争激烈时能维持常态

      #### Atomic : 竞争激烈时能维持常态，比Lock性能更好，只能同步一个值

      + #### 修饰方法 : 整个方法，作用于调用的对象

      + #### 修饰代码块 : 括起来的代码，作用于调用的对象，扩住整个方法时与上面相同

      + #### 修饰静态方法 : 整个静态方法，作用于所有对象

      + #### 修饰类 : 括起来的部分，作用于所有对象

2. ## 可见性

   ### 导致共享变量在线程间不可见的原因

   - ### 线程交叉执行

   - ### 重排序结合线程交叉执行

   - ### 共享变量更新后的值没有在工作内存与主内存间及时更新

   1. ### JMM对于Synchronized的两个规定

      + #### 线程解锁前，必须把共享变量的最新值刷新到主内存中去

      + #### 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取(加锁与解锁必须是同一把锁)

   2. ### Volatile通过加入内存屏障与禁止重排序来实现可见性

      + #### volatile变量写操作时，会在写操作后加入一条store屏障指令，将本地内存中的共享变量值刷新到主内存

      ![正事配图](https://raw.githubusercontent.com/undermoonoldman/JavaFamilyBucket/master/Resource/IMG/096.jpg)
      
      + #### volatile变量读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量
      
      ![正事配图](https://raw.githubusercontent.com/undermoonoldman/JavaFamilyBucket/master/Resource/IMG/097.jpg)

3. ## 有序性

   ### Java内存模型中，允许编译器与处理器对指令进行重排序，单线程不受重排影响多线程会受到影响

   1. ### volatile，synchromized，lock可以保证多线程的有序性

   2. ### Java内存模型保证一些场景下的有序性 happens-before原则

      + #### 程序次序规则 : 单线程内，无论重排与否，都能保证写在前面的操作先于写在后面的操作

      + #### 锁定规则 : 对一个锁的unlock先于对它的lock操作

      + #### volatile变量规则 : 对一个变量的写操作先于之后对该变量的读操作

      + #### 传递规则 : A先于B，B先于C，则A先于C

      + #### 线程启动规则 : Thread的Start方法先于此线程的每一个动作

      + #### 线程中断规则 : 对线程的interrupt方法的调用先与被中断线程的代码检测到中断事件的发生

      + #### 线程终结规则 : 线程中所有操作都先于线程的终止检测，Thread.join 来结束，Thread.isAlive 来检测线程是否已经终止

      + #### 对象终结规则 : 一个对象的初始化完成先于它的finalize方法的开始

