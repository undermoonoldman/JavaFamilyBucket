# ***并发拓展***

1. ## 死锁

   1. ### 概念

      #### 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程

   2. ### 产生条件

      ### 虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件

      1. #### 互斥条件 : 指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放

      2. #### 请求和保持条件 : 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放

      3. #### 不剥夺条件 : 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放

      4. #### 环路等待条件 : 指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源

2. ## 并发总结

   1. ### 使用本地变量

      #### 应该尽量使用本地变量，而不是创建一个类或者实例的变量

   2. ### 使用不可变类

      #### String、Integer等。不可变类可以降低代码中的需要的同步数量

   3. ### 最小化锁的作用域范围 : S=1/(1-a+a/n)

      #### a：并行计算部分所占比例

      #### n：并行处理结点个数

      #### S：加速比

      #### 当1-a等于0时，没有串行只有并行，最大加速比 S=n

      #### 当a=0时，只有串行没有并行，最小加速比 S = 1

      #### 当n→∞时，极限加速比 s→ 1/（1-a）

      #### 例如，若串行代码占整个代码的25%，则并行处理的总体性能不可能超过4。该公式称为：“阿姆达尔定律"或"安达尔定理”

   4. ### 使用线程池的Executor，而不是直接new Thread 执行

      #### 创建一个线程的代价是昂贵的，如果要创建一个可伸缩的Java应用，那么你需要使用线程池

   5. ### 宁可使用同步也不要使用线程的wait和notify

      #### Java1.5以后，增加了许多同步工具，如：CountDownLatch、CyclicBarrier、Semaphore等，应该优先使用这些同步工具

   6. ### 使用BlockingQueue实现生产-消费模式

      #### 阻塞队列不仅可以处理单个生产、单个消费，也可以处理多个生产和消费

   7. ### 使用并发集合而不是加了锁的同步集合

      #### Java提供了下面几种并发集合框架 : ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentLinkedQueue 、ConcurrentLinkedDeque

   8. ### 使用Semaphone创建有界的访问

      #### 为了建立稳定可靠的系统，对于数据库、文件系统和socket等资源必须要做有机的访问，Semaphone可以限制这些资源开销的选择，Semaphone可以以最低的代价阻塞线程等待，可以通过Semaphone来控制同时访问指定资源的线程数

   9. ### 宁可使用同步代码块，也不实用同步的方法

      #### 主要针对synchronized关键字。使用synchronized关键字同步代码块只会锁定一个对象，而不会将整个方法锁定。如果更改共同的变量或类的字段，首先应该选择的是原子型变量，然后使用volatile。如果需要互斥锁，可以考虑使用ReentrantLock

   10. ### 避免使用静态变量

       #### 静态变量在并发执行环境下会制造很多问题，如果必须使用静态变量，那么优先是它成为final变量，如果用来保存集合collection，那么可以考虑使用只读集合，否则一定要做特别多的同步处理和并发处理操作

3. ## Spring与线程安全

   ### Spring作为一个IOC容器帮助我们管理了许多bean，但Spring并没有保证它们的线程安全，而是将这个任务交给了开发者，需要开发者来编写线程安全的代码

   - #### Spring bean : singleton , prototype

     #### Spring在创建Bean时需要为其设置作用域，以singleton为例，它是Spring的默认作用域即单例模式，它的生命周期和Spring容器是一致的，只在第一次注入时会被创建，另一个prototype，每次注入都会创建

   - #### 无状态的对象

     #### 无状态的对象很适合以singleton，它不用担心多个线程的操作而导致自身状态被破坏，因此可以说每个无状态的对象都是线程安全的。我们实际使用的DAO、DTO、Entity等等各种业务对象就是无状态对象，它们只是负责执行某些操作或者传递数据，其自身不携带状态

   ### 理论上可以通过将bean的作用域都设置为prototype来保证线程安全，但这种频繁创建对象的方式会极大地影响应用的性能

